# 1. 应用UI性能问题分析
## 1.1应用UI卡顿原理

换算关系：60帧/秒-----------16ms/帧；
准则：尽量保证每次在16ms内处理完所有的CPU与GPU计算、绘制、渲染等操作，否则会造成丢帧卡顿问题。

## 1.2应用UI卡顿常见原因
人为在UI线程中做轻微耗时操作，导致UI线程卡顿；

布局Layout过于复杂，无法在16ms内完成渲染；

同一时间动画执行的次数过多，导致CPU或GPU负载过重；

View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；

View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；

内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；

冗余资源及逻辑等导致加载和执行缓慢；

臭名昭著的ANR；

## 1.3 应用UI卡顿分析解决方法

### 1.3.1 使用**HierarchyViewe**r分析UI性能：
可以分析出View嵌套的冗余层级，以及测量、布局、绘制的渲染时间。

### 1.3.2 使用GPU过度绘制分析UI性能：

| 颜色 | 含义 |
| -------- | -------- |
| 蓝色     | 	1x过度绘制     |
| 绿色     | 	2x过度绘制     |
| 淡红色     | 	3x过度绘制     |
| 红色     | 	4x过度绘制     |

-----

由于过度绘制指在屏幕的一个像素上绘制多次（譬如一个设置了背景色的TextView就会被绘制两次，一次背景一次文本；这里需要强调的是Activity设置的Theme主题的背景不被算在过度绘制层级中）

### 1.3.3 使用GPU呈现模式图及FPS考核UI性能

蓝色代表测量绘制Display List的时间
红色代表OpenGL渲染Display List所需要的时间
黄色代表CPU等待GPU处理的时间

**借助traceview和systrace来进行原因追踪**

如果是蓝色偏高，说明是单位消息里CPU太耗时，得把方法的执行都打出来看看哪个耗时。比如，在某处先看看是不是应该出现onMeasure，然后可以通过sdk自带的View布局工具，看一下哪个View的onMeasure耗时最多。

如果红色偏高，说明GPU忙不过来。优化过渡绘制，使用离屏缓存来优化。

黄色偏高，说明半透明GPU不仅在忙着绘制你的window也还忙着绘制别的，可能的情况为透明window叠加多了，window里的contentView有多个且相对复杂，或者GPU降频了等等，想具体分析需要查看GPU的trace。

画动画时蓝色偏高是不正常的

### 1.3.4 使用Lint进行资源及冗余UI布局等优化

Lint检测完后给了我们很多建议，然后处理相应的建议。

### 1.3.5 使用Memory监测及GC打印与Allocation Tracker进行UI卡顿分析

检查代码，尽量避免有些频繁触发的逻辑方法中存在大量对象分配；

尽量避免在多次for循环中频繁分配对象；

避免在自定义View的onDraw()方法中执行复杂的操作及创建对象（譬如Paint的实例化操作不要写在onDraw()方法中等）；

对于并发下载等类似逻辑的实现尽量避免多次创建线程对象，而是交给线程池处理。

**使用工具：Androis Studio Allocation Tracker**

### 1.3.6 使用Traceview和dmtracedump进行分析优化

Traceview工具是一个分析器，记录了应用程序中每个函数的执行时间，然后分析和优化相应的方法。

使用Systrace进行分析优化.

### 1.3.7 使用traces.txt文件进行ANR分析优化

按键触摸事件派发超时ANR，一般阈值为5s（设置中开启ANR弹窗，默认有事件派发才会触发弹框ANR）；

广播阻塞ANR，一般阈值为10s（设置中开启ANR弹窗，默认不弹框，只有log提示）；

服务超时ANR，一般阈值为20s（设置中开启ANR弹窗，默认不弹框，只有log提示）；

**获取ANR文件：adb pull /data/anr/traces.txt ./**

ANR文件结构：

```
//显示进程id、ANR发生时间点、ANR发生进程包名
----- pid 19073 at 2015-10-08 17:24:38 -----
Cmd line: com.example.yanbo.myapplication
//一些GC等object信息，通常可以忽略
......
//ANR方法堆栈打印信息！重点！
DALVIK THREADS (18):
"main" prio=5 tid=1 Sleeping
  | group="main" sCount=1 dsCount=0 obj=0x7497dfb8 self=0x7f9d09a000
  | sysTid=19073 nice=0 cgrp=default sched=0/0 handle=0x7fa106c0a8
  | state=S schedstat=( 125271779 68162762 280 ) utm=11 stm=1 core=0 HZ=100
  | stack=0x7fe90d3000-0x7fe90d5000 stackSize=8MB
  | held mutexes=
  at java.lang.Thread.sleep!(Native method)
  - sleeping on <0x0a2ae345> (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:1031)
  - locked <0x0a2ae345> (a java.lang.Object)
//真正导致ANR的问题点，可以发现是onClick中有sleep导致。我们平时可以类比分析即可，这里不详细说明。
  at java.lang.Thread.sleep(Thread.java:985)
  at com.example.yanbo.myapplication.MainActivity$1.onClick(MainActivity.java:21)
  at android.view.View.performClick(View.java:4908)
  at android.view.View$PerformClick.run(View.java:20389)
  at android.os.Handler.handleCallback(Handler.java:815)
  at android.os.Handler.dispatchMessage(Handler.java:104)
  at android.os.Looper.loop(Looper.java:194)
  at android.app.ActivityThread.main(ActivityThread.java:5743)
  at java.lang.reflect.Method.invoke!(Native method)
  at java.lang.reflect.Method.invoke(Method.java:372)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:988)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
......
//省略一些不常关注堆栈打印
......
```

### 1.3.8 UI性能优化总结

布局优化；尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局（譬如10层就会直接异常），尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。

列表及Adapter优化；尽量复用getView方法中的相关View，不重复获取实例导致卡顿，列表尽量在滑动过程中不进行UI元素刷新等。

背景和图片等内存分配优化；尽量减少不必要的背景设置，图片尽量压缩处理显示，尽量避免频繁内存抖动等问题出现。

自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法中，尽量减少draw、measure、layout等执行次数。

避免ANR，不要在UI线程中做耗时操作，遵守ANR规避守则，譬如多次数据库操作等。

#  2.应用开发Memory内存性能分析优化
## 2.1Android内存管理原理

![Android内存管理原理](blob:chrome-extension://cdneggiaafcmelgcaiihmhiagieomgfj/e883045f-5cc2-4bf7-b91a-9758d97dc2de)

## 2.2 Android内存泄露性能分析

### 2.2.1 Android应用内存泄露概念

单例模式的对象持有了当前Activity的强引用，那在当前Acvitivy执行完onDestroy()后，这个Activity就无法得到垃圾回收，也就造成了内存泄露。

-----

应用卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）;

应用被从后台进程干为空进程（上面系统内存原理有介绍，也就是超过了阈值）；

应用莫名的崩溃（上面应用内存原理有介绍，也就是超过了阈值OOM）；

### 2.2.3 Android应用内存泄露察觉手段

| 察觉方式 | 场景 |
| -------- | -------- |
| AS的Memory窗口     | 	平时用来直观了解自己应用的全局内存情况，大的泄露才能有感知  |
| DDMS-Heap内存监测工具  | 同上，大的泄露才能有感知  |
| dumpsys meminfo命令   | 	常用方式，可以很直观的察觉一些泄露，但不全面且常规足够用   |
| leakcanary神器    | 	比较强大，可以感知泄露且定位泄露；实质是MAT原理，只是更加自动化了，当现有代码量已经庞大成型，且无法很快察觉掌控全局代码时极力推荐；或者是偶现泄露的情况下极力推荐  |

### 2.2.4 Android应用开发规避内存泄露建议

Context使用不当造成内存泄露；不要对一个Activity Context保持长生命周期的引用（譬如上面概念部分给出的示例）。尽量在一切可以使用应用ApplicationContext代替Context的地方进行替换（原理我前面有一篇关于Context的文章有解释）。

非静态内部类的静态实例容易造成内存泄漏；即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。

警惕线程未终止造成的内存泄露；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是HandlerThread的run方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运thread.getLooper().quit();才不会泄露。

对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。

创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。

不要在执行频率很高的方法或者循环中创建对象，可以使用HashTable等创建一组对象容器从容器中取那些对象，而不用每次new与释放。

避免代码设计模式的错误造成内存泄露。

## 2.3 Android内存溢出OOM性能分析

### 2.3.1 Android应用内存溢出OOM概念

应用代码存在内存泄露，长时间积累无法释放导致OOM；

应用的某些逻辑操作疯狂的消耗掉大量内存（譬如加载一张不经过处理的超大超高清图片等）导致超过阈值OOM；

### 2.3.2 Android应用规避内存溢出OOM建议

时刻记得不要加载过大的Bitmap对象；譬如对于类似图片加载我们要通过BitmapFactory.Options设置图片的一些采样比率和复用等，具体做法点我参考官方文档，不过过我们一般都用fresco或Glide开源库进行加载。

优化界面交互过程中频繁的内存使用；譬如在列表等操作中只加载可见区域的Bitmap、滑动时不加载、停止滑动后再开始加载。

有些地方避免使用强引用，替换为弱引用等操作。

避免各种内存泄露的存在导致OOM。

对批量加载等操作进行缓存设计，譬如列表图片显示，Adapter的convertView缓存等。

尽可能的复用资源；譬如系统本身有很多字符串、颜色、图片、动画、样式以及简单布局等资源可供我们直接使用，我们自己也要尽量复用style等资源达到节约内存。

对于有缓存等存在的应用尽量实现onLowMemory()和onTrimMemory()方法。

尽量使用线程池替代多线程操作，这样可以节约内存及CPU占用率。

尽量管理好自己的Service、Thread等后台的生命周期，不要浪费内存占用。

尽可能的不要使用依赖注入，中看不中用。

尽量在做一些大内存分配等可疑内存操作时进行try catch操作，避免不必要的应用闪退。

尽量的优化自己的代码，减少冗余，进行编译打包等优化对齐处理，避免类加载时浪费内存。

## 2.4 Android应用API使用及代码逻辑性能分析

### 2.4.1 Android应用String/StringBuilder/StringBuffer优化建议

StringBuffer 线程安全，在不考虑多线程情况下StringBuilder的性能又比StringBuffer高

### 2.4.2 Android应用OnTrimMemory()实现性能建议

```
@Override
public void onTrimMemory(int level) {
   if (level >= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearCache();
   }
}
```

### 2.4.5 Android应用其他逻辑优化建议

避免在Android中使用Java的枚举类型，因为编译后不但占空间，加载也费时，完全没有static final的变量好用、高效。

Handler发送消息时尽量使用obtain去获取已经存在的Message对象进行复用，而不是新new Message对象，这样可以减轻内存压力。

在使用后台Service时尽量将能够替换为IntentService的地方替换为此，这样可以减轻系统压力、省电、省内存、省CPU占用率。

在当前类内部尽量不要通过自己的getXXX、setXXX对自己内部成员进行操作，而是直接使用，这样可以提高代码执行效率。

不要一味的为了设计模式而过分的抽象代码，因为代码抽象系数与代码加载执行时间成正比。

尽量减少锁个数、减小锁范围，避免造成性能问题。

合理的选择使用for循环与增强型for循环，譬如不要在ArrayList上使用增强型for循环等

# 3.Android应用耗电量优化建议

在需要网络的应用中，执行某些操作前尽量先进行网络状态判断。

在网络应用传输中使用高效率的数据格式和解析方法，譬如JSON等。

在传输用户反馈或者下载OTA升级包等不是十分紧急的操作时尽量采用压缩数据进行传输且延迟到设备充电和WIFI状态时进行。

在有必要的情况下尽量通过PowerManager.WakeLock和JobScheduler来控制一些逻辑操作达到省电优化。

对定位要求不太高的场景尽量使用网络定位，而不是GPS定位。

对于定时任务尽量使用AlarmManager，而不是sleep或者Timer进行管理。

尽可能的减少网络请求次数和减小网络请求时间间隔。

后台任务要尽可能少的唤醒CPU，譬如IM通信的长连接心跳时间间隔、一些应用的后台定时唤醒时间间隔等要设计合理。

特殊耗电业务情况可以进行弹窗等友好的交互设计提醒用户该操作会耗用过多电量。
